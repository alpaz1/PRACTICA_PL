package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;
import alex.TokenValue;
import ast.*;
import ast.Expresions.*;
import ast.Instructions.*;
import ast.Types.*;
import ast.Estructuras.*;
import ast.Estructuras.clases.*;
import ast.Auxiliares.*;
import ast.Accesos.*;
import java.util.List;
import java.util.ArrayList;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal    TokenValue MAYOR, IDEN, MENOR, PUNTOYCOMA, TIPOINT, TIPOBOOL, TIPOFLOAT, VOID, ENT, MAIN, PUNTO, DOSPUNTOS, CLASS, PRIVATE,
            ENUM, LLAP, LLCIERRE, CAP, CCIERRE, STRUCT, POR, RETURN, IF, ELSE, PAP, PCIERRE, WHILE, DIV, ARROBA, PUBLIC, PROTECTED,
            FOR, AND, OR, IGUALDAD , DISTINTO, MAYORIGUAL, MENORIGUAL, MAS, MENOS, MOD, TRUE, FALSE, NEW, COMA, NEGACION, TYPEDEF,
            PRINT, READ, SWITCH, BREAK, DEFAULT, CASE, IGUAL, AMPERSAND, INCLUDE, ALMOHADILLA, COMILLASDOBLES, REAL, ARRAY;


non terminal Programa P;
non terminal FMain Principal;
non terminal Modulo Modulos;
non terminal List<Instruccion> ListaInstrucciones;
non terminal List<Declaracion> ListaCampos;
non terminal Instruccion Instruccion;
non terminal Alias Alias;
non terminal Acceso Acceso0,Acceso1;
non terminal StructClass DeclaracionRegistro;
non terminal Declaracion Declaracion;
non terminal PrivacyMode ModAcceso; 
non terminal Clase Clase,CuerpoClase;
non terminal Atributo Atributo;
non terminal Constructor Constructor;
non terminal Metodo Metodo;
non terminal Asignacion Asignacion;
non terminal Condicional Condicional;
non terminal Devuelve Return;
non terminal Imprime Print;
non terminal Lee Read;
non terminal Bloque Iteracion;
non terminal Bloque Bloque;
non terminal Switch Selecciona;
non terminal List<CasoSwitch> Casos;
non terminal CasoSwitch Caso;
non terminal CasoSwitch PorDefecto;
non terminal Funcion Funcion;
non terminal Parametro Parametro;
non terminal LlamadaFunExp LlamadaFuncion,LlamadaConstructor;
non terminal List<Parametro> ListaParametros;
non terminal List<Parametro> Parametros;
non terminal List<E> ListaArgumentos;
non terminal EnumClass DeclaracionEnumerado;
non terminal List<String> ListaEnumerado;
non terminal DefinitionsList Declaraciones;
non terminal Types Tipo;
non terminal E E0,E1,E2,E3,E4,E5,E6,E7;


P ::= Declaraciones:decs Principal:p
                  {: RESULT = new Programa(decs, p);:};

Declaraciones ::= Declaracion:d PUNTOYCOMA Declaraciones:decs
                    {: decs.addBasic(d);RESULT = decs; :} 
                | Alias:a PUNTOYCOMA Declaraciones:decs
                    {:decs.addAlias(a); RESULT = decs;:}
                | DeclaracionEnumerado:d PUNTOYCOMA Declaraciones:decs
                    {:decs.addEnum(d); RESULT = decs;:}
                | DeclaracionRegistro:s PUNTOYCOMA Declaraciones:decs
                    {:decs.addStruct(s);RESULT = decs;:}
                | Modulos:m Declaraciones:decs
                    {:decs.addModulo(m);RESULT = decs;:}
                | Funcion:f Declaraciones:decs
                    {:decs.addFuncion(f); RESULT = decs;:}
                | Clase:clase Declaraciones:decs
                    {:decs.addClase(clase);RESULT=decs;:}
                |
                    {: RESULT = new DefinitionsList(); :};

Acceso0 ::= Acceso0:ref CAP E0:exp CCIERRE 
            {: RESULT = new AccesoArray(ref,exp); :}
            | Acceso0:ref PUNTO IDEN:campo 
            {: RESULT = new AccesoStruct(ref,campo.lexema); :}
            | Acceso0:ref PUNTO IDEN:metodo PAP ListaArgumentos:arglist PCIERRE
            {: RESULT = new AccesoMetodo(ref,new LlamadaFunExp(metodo.lexema,arglist));:}
            | Acceso1:ref
            {: RESULT = ref; :};
Acceso1 ::= IDEN:nombre
            {: RESULT = new AccesoVar(nombre.lexema); :}
            | ARROBA Acceso1:ref
            {: RESULT = new AccesoPuntero(ref); :}
            | ARROBA PAP Acceso0:ref PCIERRE
            {: RESULT = new AccesoPuntero(ref); :};


Declaracion ::= Tipo:t IDEN:n IGUAL E0:exp
                    {:RESULT = new Declaracion(t.kind(), n.lexema, exp);:}
                | Tipo:t IDEN:n
                    {:RESULT = new Declaracion(t.kind(), n.lexema);:};

Asignacion ::= Acceso0:ref IGUAL E0:exp
               {:RESULT = new Asignacion(ref,exp);:};


Tipo ::=  TIPOINT 
            {:RESULT= new BasicTypes(KindTypes.INT);:}
          | TIPOFLOAT 
            {:RESULT= new BasicTypes(KindTypes.FLOAT);:}
          | TIPOBOOL 
            {:RESULT= new BasicTypes(KindTypes.BOOL);:}
          | VOID                    
            {:RESULT= new BasicTypes(KindTypes.VOID);:}
          | IDEN:nombre
            {:RESULT = new StructType(nombre.lexema);:}
          | ARRAY MENOR Tipo:t MAYOR CAP E0:tam CCIERRE
            {:RESULT = new ArrayType(t,tam);:}
          | ARRAY MENOR Tipo:t MAYOR CAP CCIERRE
            {:RESULT = new ArrayType(t,null);:}
          | Tipo:t POR
            {:RESULT = new PointerType(t);:};

Alias ::= TYPEDEF IDEN:nombre IGUAL Tipo:tipo
          {:RESULT = new Alias(nombre.lexema,tipo);:};

Modulos ::= ALMOHADILLA INCLUDE COMILLASDOBLES IDEN:nombre PUNTO IDEN:ext COMILLASDOBLES
            {:RESULT = new Modulo(nombre.lexema,ext.lexema);:};
Principal ::= MAIN PAP PCIERRE LLAP ListaInstrucciones:instList LLCIERRE 
            {:RESULT= new FMain(instList);:};
ListaInstrucciones ::= Instruccion:ins PUNTOYCOMA ListaInstrucciones:insList 
                        {:RESULT = insList; insList.add(ins);:}
                     | Bloque:block ListaInstrucciones:insList
                        {:RESULT = insList; insList.add(block);:}
                     | 
                        {:RESULT = new ArrayList<Instruccion>();:};

Instruccion ::= Declaracion:dec
                  {:RESULT = dec;:}
              | Asignacion:as
                  {:RESULT = as;:}
              | Return:ret
                  {:RESULT =ret;:}
              | Print:pr
                  {:RESULT = pr;:}
              // | Read:re
              //     {:RESULT=re;:}
              | LlamadaFuncion:fun
                  {:RESULT = new LlamadaFunInst(fun);:};

//---------------------Clases-----------------------------------

Clase::= ModAcceso:modo CLASS IDEN:nombre LLAP CuerpoClase:clase LLCIERRE
              {:clase.setName(nombre.lexema);clase.setModo(modo);RESULT= clase;:};
CuerpoClase ::= Atributo:a CuerpoClase:clase
               {:clase.addAtrib(a);RESULT=clase;:}
               | Constructor:c CuerpoClase:clase
               {:clase.addConstr(c);RESULT=clase;:}
               | Metodo:m CuerpoClase:clase
               {:clase.addMetodo(m);RESULT=clase;:}
               |
               {:RESULT = new Clase();:};

Atributo ::= ModAcceso:modo Declaracion:dec PUNTOYCOMA
              {:RESULT = new Atributo(modo,dec);:};
Constructor::= ModAcceso:modo IDEN PAP Parametros:param PCIERRE LLAP ListaInstrucciones:inst LLCIERRE
                {:RESULT = new Constructor(modo,param,inst);:};
Metodo ::= ModAcceso:modo Funcion:fun
            {:RESULT = new Metodo(modo,fun);:};

ModAcceso::= PUBLIC
            {:RESULT = PrivacyMode.PUBLIC;:}
            | PRIVATE
            {:RESULT = PrivacyMode.PRIVATE;:} 
            | PROTECTED
            {:RESULT = PrivacyMode.PROTECTED;:};

LlamadaConstructor ::= NEW IDEN:nombreClase PAP ListaArgumentos:argList PCIERRE
                      {:RESULT = new LlamadaFunExp(nombreClase.lexema,argList);:};
// ------------------------ Instrucciones ------------------------

// Llamada a función como expresión
LlamadaFuncion ::= IDEN:nombre PAP ListaArgumentos:args PCIERRE
                  {:RESULT = new LlamadaFunExp(nombre.lexema,args);:};
      
ListaArgumentos ::= E0:arg COMA ListaArgumentos:arglist 
                {:arglist.add(arg); RESULT = arglist;:}
              | E0:exp
                {: RESULT =  new ArrayList<E>(); RESULT.add(exp);  :}
              |
                {: RESULT = new ArrayList<E>(); :};

Print ::= PRINT PAP E0:exp PCIERRE 
         {: RESULT = new Imprime(exp); :};

Read ::= READ PAP PCIERRE 
         {:RESULT = new Lee();:};

Return ::= RETURN E0:exp 
            {:RESULT = new Devuelve(exp);:}
          | RETURN 
            {:RESULT = new Devuelve();:};

// ------------------------ Bloques ------------------------
Bloque ::= Condicional:block
              {:RESULT= block;:}
           | Iteracion:block
              {:RESULT = block;:}
           | Selecciona:sel
                  {:RESULT = sel;:}
           | LLAP ListaInstrucciones:ins LLCIERRE
              {:RESULT = new Bloque(ins);:};

Condicional ::= IF PAP E0:exp PCIERRE LLAP ListaInstrucciones:ins LLCIERRE
              {: RESULT = new Condicional(exp,ins); :}
              | IF PAP E0:exp PCIERRE LLAP ListaInstrucciones:ins LLCIERRE ELSE LLAP ListaInstrucciones:inselse LLCIERRE
              {: RESULT = new Condicional(exp,ins,inselse); :};

Iteracion ::= WHILE PAP E0:exp PCIERRE LLAP ListaInstrucciones:list LLCIERRE
              {:RESULT = new BucleWhile(exp,list);:}
              | FOR PAP Declaracion:dec PUNTOYCOMA E0:exp PUNTOYCOMA Asignacion:asig PCIERRE LLAP ListaInstrucciones:list LLCIERRE
               {:RESULT = new BucleFor(dec, exp, asig, list );:}
              | FOR PAP PUNTOYCOMA E0:exp PUNTOYCOMA Asignacion:asig PCIERRE LLAP ListaInstrucciones:list LLCIERRE
               {:RESULT = new BucleFor(exp,asig,list);:};


Selecciona ::= SWITCH PAP IDEN:nombre PCIERRE LLAP Casos:casos PorDefecto:def LLCIERRE
            {:RESULT= new Switch(nombre.lexema,casos,def);:}
            | SWITCH PAP IDEN:nombre PCIERRE LLAP Casos:casos LLCIERRE
            {:RESULT= new Switch(nombre.lexema,casos);:};
Casos ::= Caso:caso Casos:casos 
           {: casos.add(caso); RESULT = casos; :}
          |
          {: RESULT = new ArrayList<CasoSwitch>();:};
Caso ::= CASE E0:exp DOSPUNTOS ListaInstrucciones:inst BREAK PUNTOYCOMA
          {:RESULT= new CasoSwitch(exp,inst,true);:}
          | CASE E0:exp DOSPUNTOS ListaInstrucciones:inst
          {:RESULT= new CasoSwitch(exp,inst,false);:};
PorDefecto ::= DEFAULT DOSPUNTOS ListaInstrucciones:inst
              {:RESULT= new CasoSwitch(inst);:};

// ----------------------Funciones--------------------------
Funcion ::= Tipo:t IDEN:id PAP Parametros:paramList PCIERRE LLAP ListaInstrucciones:instList LLCIERRE
              {:RESULT= new Funcion(t.kind(), id.lexema, paramList, instList);:};
Parametros ::= ListaParametros:paramList
              {:RESULT = paramList;:}
              | 
              {:RESULT = new ArrayList<Parametro>();:};
ListaParametros ::= Parametro:param COMA ListaParametros:paramList
                    {:paramList.add(param); RESULT = paramList;:}
                  | Parametro:param
                    {:List<Parametro> paramList = new ArrayList<Parametro>(); paramList.add(param); RESULT = paramList;:};
Parametro ::= Tipo:t IDEN:id
              {:RESULT = new Parametro(t.kind(), id.lexema, false);:}
            | Tipo:t AMPERSAND IDEN:id
              {:RESULT = new Parametro(t.kind(), id.lexema, true);:};

//---------------------Otros tipos ----------------------------
DeclaracionEnumerado ::= ENUM IDEN:n LLAP ListaEnumerado:campos LLCIERRE
                            {:RESULT= new EnumClass(n.lexema, campos);:};
ListaEnumerado ::= IDEN:campo COMA ListaEnumerado:campos
                    {:campos.add(campo.lexema); RESULT = campos;:}
                 | IDEN:campo
                    {:List<String> campos = new ArrayList<String>(); campos.add(campo.lexema); RESULT = campos;:};
DeclaracionRegistro ::= STRUCT IDEN:nombre LLAP ListaCampos:valores LLCIERRE
                    {:RESULT = new StructClass(nombre.lexema,valores);:};
ListaCampos ::= Declaracion:dec PUNTOYCOMA ListaCampos:valores
                {:valores.add(dec); RESULT = valores;:} 
                | Declaracion:dec PUNTOYCOMA
                {:List<Declaracion> decs = new ArrayList<Declaracion>();decs.add(dec);RESULT = decs;:};


//------------------ Expresiones ----------------------------

E0 ::= E0:opIzq OR E1:opDer
        {:RESULT= new EBin(opIzq, opDer, KindE.OR);:}
     | E1:e
        {:RESULT = e;:};

E1 ::= E1:opIzq AND E2:opDer 
        {:RESULT= new EBin(opIzq, opDer, KindE.AND);:}
     | E2:e
        {:RESULT = e;:};

E2 ::= E2:opIzq IGUALDAD E3:opDer
          {:RESULT= new EBin(opIzq, opDer, KindE.IGUALDAD);:}
      | E2:opIzq DISTINTO E3:opDer
          {:RESULT= new EBin(opIzq, opDer, KindE.DISTINTO);:}
      | E3:e
          {:RESULT = e;:};

E3 ::= E3:opIzq MAYOR E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MAYOR);:}
      | E3:opIzq MENOR E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MENOR);:}
      | E3:opIzq MAYORIGUAL E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MAYORIGUAL);:}
      | E3:opIzq MENORIGUAL E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MENORIGUAL);:}
      | E4:e
          {:RESULT = e;:};

E4 ::= E4:opIzq MAS E5:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.SUMA);:}
      | E4:opIzq MENOS E5:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.RESTA);:}
      | E5:e
          {:RESULT = e;:};

E5 ::= E5:opIzq POR E6:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MUL);:}
      | E5:opIzq DIV E6:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.DIV);:}
      | E5:opIzq MOD E6:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MOD);:}
      | E6:e
          {:RESULT = e;:};

E6 ::= MENOS E6:exp
        {:RESULT = new EUnaria(exp,KindE.MENOS);:}
      | NEGACION E6:exp
       {:RESULT = new EUnaria(exp, KindE.NEG);:} 
      | E7:e
          {:RESULT = e;:};

E7 ::= TRUE:valor
        {:RESULT = new Const(valor.lexema, KindE.BOOL);:}
      | FALSE:valor
        {:RESULT = new Const(valor.lexema, KindE.BOOL);:}
      | ENT:valor
        {:RESULT = new Const(valor.lexema, KindE.ENT);:}
      | REAL:valor
        {:RESULT = new Const(valor.lexema, KindE.FLOAT);:}
      | Acceso0:ref
        {:RESULT=ref;:}
      | LlamadaFuncion:llamada
        {:RESULT=llamada;:}
      | Read:llamada
        {:RESULT=llamada;:}
      | LlamadaConstructor:llamada
        {:RESULT=llamada;:}
      | PAP E0:exp PCIERRE
        {:RESULT = exp;:}
      | LLAP ListaArgumentos:lst LLCIERRE
        {:RESULT = new Const(lst.toString(), KindE.ARRAY);:};