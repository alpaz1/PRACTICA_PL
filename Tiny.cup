package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;
import alex.TokenValue;
import ast.*;
import ast.Expresions.*;
import ast.Instructions.*;
import ast.Types.*;
import ast.Estructuras.*;
import ast.Estructuras.clases.*;
import ast.Auxiliares.*;
import java.util.List;
import java.util.ArrayList;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal    TokenValue MAYOR ,IDEN, MENOR, PUNTOYCOMA, TIPOINT,TIPOBOOL,TIPOFLOAT, VOID, ENT, MAIN, PUNTO, DOSPUNTOS, CLASS, PRIVATE,
            ENUM, LLAP, LLCIERRE, CAP, CCIERRE, STRUCT,POR, RETURN, IF, ELSE, PAP, PCIERRE, WHILE, DIV, ARROBA, PUBLIC, PROTECTED,
            FOR, AND, OR, IGUALDAD , DISTINTO, MAYORIGUAL, MENORIGUAL, MAS, MENOS, MOD, TRUE, FALSE, NEW, COMA, NEGACION, TYPEDEF,
            PRINT, READ, SWITCH, BREAK, DEFAULT, CASE, IGUAL, UNVERSAND, INCLUDE, ALMOHADILLA, COMILLASDOBLES, REAL, ARRAY;

non terminal  ArraysDim, Alias, AsignacionArray,
              ListaCampos, Argumentos,
              Modulos, InsParada, ListaValores,
              AcesoStruct, AcesoArray, ListaAcesoArray, AsigPosArray;


non terminal Programa P;
non terminal Funcion Principal;
non terminal List<Instruccion> ListaInstrucciones;
non terminal Instruccion Instruccion;
non terminal StructClass DeclaracionRegistro;
non terminal Declaracion Declaracion;
non terminal PrivacyMode ModAcceso; 
non terminal Clase Clase,CuerpoClase;
non terminal Atributo Atributo;
non terminal Constructor Constructor;
non terminal Metodo Metodo;
non terminal Asignacion Asignacion, InsFor;
non terminal Condicional Condicional;
non terminal Devuelve Return;
non terminal Imprime Print;
non terminal Lee Read;
non terminal Bloque Iteracion;
non terminal Bloque Bloque;
non terminal Switch Selecciona;
non terminal List<CasoSwitch> Casos;
non terminal CasoSwitch Caso;
non terminal CasoSwitch PorDefecto;
non terminal Funcion Funcion;
non terminal Parametro Parametro;
non terminal LlamadaFunExp LlamadaFuncion;
non terminal List<Parametro> ListaParametros;
non terminal List<Parametro> Parametros;
non terminal List<E> ListaArgumentos;
non terminal EnumClass DeclaracionEnumerado;
non terminal List<String> ListaEnumerado;
non terminal DefinitionsList Declaraciones;
non terminal Types Tipo;
non terminal E E0,E1,E2,E3,E4,E5,E6,E7;


P ::= Declaraciones:decs Principal:p
                  {: RESULT = new Programa(decs, p);:};

Declaraciones ::= Declaracion:d PUNTOYCOMA Declaraciones:decs
                    {: decs.addBasic(d);RESULT = decs; :} 
                | DeclaracionEnumerado:d PUNTOYCOMA Declaraciones:decs
                    {:decs.addEnum(d); RESULT = decs;:}
                | Modulos Declaraciones:decs
                | Funcion:f Declaraciones:decs
                    {:decs.addFuncion(f); RESULT = decs;:}
                | Clase:clase Declaraciones:decs
                    {:decs.addClase(clase);RESULT=decs;:}
                |
                    {: RESULT = new DefinitionsList(); :};

Declaracion ::= Tipo:t Asignacion:a
                    {:RESULT = new Declaracion(t.kind(), a.getId(), a.getValor());:}
                | Tipo:t IDEN:n
                    {:RESULT = new Declaracion(t.kind(), n.lexema);:}
                | DeclaracionRegistro
                | Alias;

Asignacion ::= IDEN:n IGUAL E0:valor
                 {:RESULT = new Asignacion(n.lexema, valor);:}
            |  IDEN:n IGUAL AsignacionArray:valor
                 {:RESULT = new Asignacion(n.lexema, valor);:}
            |  ARROBA IDEN IGUAL E0
            |  IDEN IGUAL AcesoArray;
AsignacionArray ::= LLAP E0:e ListaValores:l LLCIERRE
                    //  {:  l.add(e); RESULT = l;:}
                   | LLAP AsignacionArray:a ListaValores:l LLCIERRE
                     ;// {: l.add(a);RESULT = l;:};

ListaValores ::= COMA E0:e ListaValores:l
                   //   {:l.add(e); RESULT = l;:}
                | COMA AsignacionArray:a ListaValores:l
                    //   {:l.add(a); RESULT = l;:}
                |; //{:RESULT =  new ArrayList<Object>(); :};


Tipo ::= ARRAY MENOR Tipo:t MAYOR ArraysDim
            {:RESULT = new BasicTypes(KindTypes.ARRAY);:}
          | TIPOINT 
            {:RESULT= new BasicTypes(KindTypes.INT);:}
          | TIPOFLOAT 
            {:RESULT= new BasicTypes(KindTypes.FLOAT);:}
          | TIPOBOOL 
            {:RESULT= new BasicTypes(KindTypes.BOOL);:}
          //| VOID                                                        ----------- Da problemas de shif reduce -----------
          //  {:RESULT= new BasicTypes(KindTypes.VOID);:}
          | IDEN
          | Tipo POR;

Alias ::= TYPEDEF IDEN IGUAL Tipo;
ArraysDim ::= CAP E0 CCIERRE| CAP CCIERRE;
Modulos ::= ALMOHADILLA INCLUDE COMILLASDOBLES IDEN PUNTO IDEN COMILLASDOBLES;
Principal ::= VOID MAIN PAP PCIERRE LLAP ListaInstrucciones:instList LLCIERRE 
                {:RESULT= new Funcion(KindTypes.VOID, "principal", new ArrayList<Parametro>(),instList);:};
ListaInstrucciones ::= Instruccion:ins PUNTOYCOMA ListaInstrucciones:insList 
                        {:insList.add(ins); RESULT = insList;:}
                     | Bloque:block ListaInstrucciones:insList
                        {:insList.add(block); RESULT = insList;:}
                     | 
                        {:RESULT = new ArrayList<Instruccion>();:};

Instruccion ::= Declaracion:dec
                  {:RESULT = dec;:}
              | Asignacion:as
                  {:RESULT = as;:}
              | Return:ret
                  {:RESULT =ret;:}
              | Print:pr
                  {:RESULT = pr;:}
              | Read:re
                  {:RESULT=re;:}
              | LlamadaFuncion:fun
                  {:RESULT = new LlamadaFunInst(fun);:}
              | AcesoStruct 
              | AcesoArray;

//---------------------Clases-----------------------------------

Clase::= ModAcceso:modo CLASS IDEN:nombre LLAP CuerpoClase:clase LLCIERRE
              {:clase.setName(nombre.lexema);clase.setModo(modo);RESULT= clase;:};
CuerpoClase ::= Atributo:a CuerpoClase:clase
               {:clase.addAtrib(a);RESULT=clase;:}
               | Constructor:c CuerpoClase:clase
               {:clase.addConstr(c);RESULT=clase;:}
               | Metodo:m CuerpoClase:clase
               {:clase.addMetodo(m);RESULT=clase;:}
               |
               {:RESULT = new Clase();:};

Atributo ::= ModAcceso:modo Declaracion:dec PUNTOYCOMA
              {:RESULT = new Atributo(modo,dec);:};
Constructor::= ModAcceso:modo IDEN PAP Parametros:param PCIERRE LLAP ListaInstrucciones:inst LLCIERRE
                {:RESULT = new Constructor(modo,param,inst);:};
Metodo ::= ModAcceso:modo Funcion:fun
            {:RESULT = new Metodo(modo,fun);:};

ModAcceso::= PUBLIC
            {:RESULT = PrivacyMode.PUBLIC;:}
            | PRIVATE
            {:RESULT = PrivacyMode.PRIVATE;:} 
            | PROTECTED
            {:RESULT = PrivacyMode.PROTECTED;:};
// ------------------------ Instrucciones ------------------------

// Llamada a función como expresión
LlamadaFuncion ::= IDEN:nombre PAP ListaArgumentos:args PCIERRE
                  {:RESULT = new LlamadaFunExp(nombre.lexema,args);:};
      
ListaArgumentos ::= E0:arg COMA ListaArgumentos:arglist 
                {:arglist.add(arg); RESULT = arglist;:}
              | E0:exp
                {: RESULT =  new ArrayList<E>(); RESULT.add(exp);  :}
              |
                {: RESULT = new ArrayList<E>(); :};

Print ::= PRINT PAP E0:exp PCIERRE 
         {: RESULT = new Imprime(exp); :};

Read ::= READ PAP PCIERRE 
         {:RESULT = new Lee();:};

Return ::= RETURN E0:exp 
            {:RESULT = new Devuelve(exp);:}
          | RETURN 
            {:RESULT = new Devuelve();:};

// ------------------------ Bloques ------------------------
Bloque ::= Condicional:block
              {:RESULT= block;:}
           | Iteracion:block
              {:RESULT = block;:}
           | Selecciona:sel
                  {:RESULT = sel;:}
           | LLAP ListaInstrucciones:ins LLCIERRE
              {:RESULT = new Bloque(ins);:};

Condicional ::= IF PAP E0:exp PCIERRE LLAP ListaInstrucciones:ins LLCIERRE
              {: RESULT = new Condicional(exp,ins); :}
              | IF PAP E0:exp PCIERRE LLAP ListaInstrucciones:ins LLCIERRE ELSE LLAP ListaInstrucciones:inselse LLCIERRE
              {: RESULT = new Condicional(exp,ins,inselse); :};

Iteracion ::= WHILE PAP E0:exp PCIERRE LLAP ListaInstrucciones:list LLCIERRE
              {:RESULT = new BucleWhile(exp,list);:}
              | FOR PAP InsFor:var E0:exp PUNTOYCOMA Asignacion:asig PCIERRE LLAP ListaInstrucciones:list LLCIERRE
               {:RESULT = new BucleFor(var, exp, asig, list );:};

InsFor ::= TIPOINT Asignacion:var PUNTOYCOMA 
              {:RESULT = var;:}
          | Asignacion:var PUNTOYCOMA 
               {:RESULT = var;:}
          | PUNTOYCOMA;
Selecciona ::= SWITCH PAP IDEN:nombre PCIERRE LLAP Casos:casos PorDefecto:def LLCIERRE
            {:RESULT= new Switch(nombre.lexema,casos,def);:}
            | SWITCH PAP IDEN:nombre PCIERRE LLAP Casos:casos LLCIERRE
            {:RESULT= new Switch(nombre.lexema,casos);:};
Casos ::= Caso:caso Casos:casos 
           {: casos.add(caso); RESULT = casos; :}
          |
          {: RESULT = new ArrayList<CasoSwitch>();:};
Caso ::= CASE E0:exp DOSPUNTOS ListaInstrucciones:inst InsParada
          {:RESULT= new CasoSwitch(exp,inst);:};
PorDefecto ::= DEFAULT DOSPUNTOS ListaInstrucciones:inst
              {:RESULT= new CasoSwitch(inst);:};
InsParada ::= BREAK PUNTOYCOMA | ;

AcesoArray ::= IDEN CAP E4 CCIERRE ListaAcesoArray| IDEN CAP E4 CCIERRE ListaAcesoArray AsigPosArray;
AsigPosArray ::= IGUAL E0| IGUAL IDEN CAP E4 CCIERRE ListaAcesoArray;
ListaAcesoArray ::= CAP E4 CCIERRE ListaAcesoArray|;

AcesoStruct ::= IDEN PUNTO IDEN | IDEN PUNTO Asignacion;

// ----------------------Funciones--------------------------
Funcion ::= Tipo:t IDEN:id PAP Parametros:paramList PCIERRE LLAP ListaInstrucciones:instList LLCIERRE
              {:RESULT= new Funcion(t.kind(), id.lexema, paramList, instList);:};
Parametros ::= ListaParametros:paramList
              {:RESULT = paramList;:}
              | 
              {:RESULT = new ArrayList<Parametro>();:};
ListaParametros ::= Parametro:param COMA ListaParametros:paramList
                    {:paramList.add(param); RESULT = paramList;:}
                  | Parametro:param
                    {:List<Parametro> paramList = new ArrayList<Parametro>(); paramList.add(param); RESULT = paramList;:};
Parametro ::= Tipo:t IDEN:id
              {:RESULT = new Parametro(t.kind(), id.lexema, false);:}
            | Tipo:t UNVERSAND IDEN:id
              {:RESULT = new Parametro(t.kind(), id.lexema, true);:};

//---------------------Otros tipos ----------------------------
DeclaracionEnumerado ::= ENUM IDEN:n LLAP ListaEnumerado:campos LLCIERRE
                            {:RESULT= new EnumClass(n.lexema, campos);:};
ListaEnumerado ::= IDEN:campo COMA ListaEnumerado:campos
                    {:campos.add(campo.lexema); RESULT = campos;:}
                 | IDEN:campo
                    {:List<String> campos = new ArrayList<String>(); campos.add(campo.lexema); RESULT = campos;:};
DeclaracionRegistro ::= STRUCT IDEN LLAP ListaCampos LLCIERRE;
ListaCampos ::= Tipo IDEN PUNTOYCOMA| Tipo IDEN PUNTOYCOMA ListaCampos;


//------------------ Expresiones ----------------------------

E0 ::= E0:opIzq OR E1:opDer
        {:RESULT= new EBin(opIzq, opDer, KindE.OR);:}
     | E1:e
        {:RESULT = e;:};

E1 ::= E1:opIzq AND E2:opDer 
        {:RESULT= new EBin(opIzq, opDer, KindE.AND);:}
     | E2:e
        {:RESULT = e;:};

E2 ::= E2:opIzq IGUALDAD E3:opDer
          {:RESULT= new EBin(opIzq, opDer, KindE.IGUALDAD);:}
      | E2:opIzq DISTINTO E3:opDer
          {:RESULT= new EBin(opIzq, opDer, KindE.DISTINTO);:}
      | E3:e
          {:RESULT = e;:};

E3 ::= E3:opIzq MAYOR E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MAYOR);:}
      | E3:opIzq MENOR E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MENOR);:}
      | E3:opIzq MAYORIGUAL E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MAYORIGUAL);:}
      | E3:opIzq MENORIGUAL E4:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MENORIGUAL);:}
      | E4:e
          {:RESULT = e;:};

E4 ::= E4:opIzq MAS E5:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.SUMA);:}
      | E4:opIzq MENOS E5:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.RESTA);:}
      | E5:e
          {:RESULT = e;:};

E5 ::= E5:opIzq POR E6:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MUL);:}
      | E5:opIzq DIV E6:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.DIV);:}
      | E5:opIzq MOD E6:opDer
          {:RESULT = new EBin(opIzq, opDer, KindE.MOD);:}
      | E6:e
          {:RESULT = e;:};

E6 ::= MENOS E6:exp
        {:RESULT = new EUnaria(exp,KindE.MENOS);:}
      | NEGACION E6:exp
       {:RESULT = new EUnaria(exp, KindE.NEG);:} 
      | E7:e
          {:RESULT = e;:};

E7 ::= TRUE:valor
        {:RESULT = new Const(valor.lexema, KindE.BOOL);:}
      | FALSE:valor
        {:RESULT = new Const(valor.lexema, KindE.BOOL);:}
      | ENT:valor
        {:RESULT = new Const(valor.lexema, KindE.ENT);:}
      | REAL:valor
        {:RESULT = new Const(valor.lexema, KindE.FLOAT);:}
      | IDEN:valor
        {:RESULT = new Const(valor.lexema, KindE.IDENTIFICADOR);:}
      | IDEN PUNTO IDEN
      | ARROBA IDEN
      | LlamadaFuncion:llamada
        {:RESULT=llamada;:}
      | NEW Tipo PAP Argumentos PCIERRE
      | PAP E0 PCIERRE;







