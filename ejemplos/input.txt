#incluir "hola.txt"
#incluir "pruebaaa.h"


enum DiaSemana { Lunes, Martes, Miercoles, Jueves, Viernes, Sabado, Domingo};
enum Resultado {accepted, timelimit, wrongAnswer};
alias matriz = lista <lista <DiaSemana>[2]> [3];
alias alejandro = flotante;

// Estructura para representar el tiempo
estructura Tiempo{
    entero hora;
    entero minuto;
    flotante segundo;
};

// Clase personalizada
publico clase miClase{
    privado entero a = 1;
    privado lista <lista <DiaSemana>[2]> [3] miAray = {{Lunes,Martes}};
    publico Tiempo tiempo;
    
    publico miClase(Tiempo& t, entero ab){
        tiempo = t;
        DiaSemana d = Martes;
        miAray[1][2] = Jueves;
    }

    privado void fun(buleano b){
        b = mentira;
    }
}

lista <Tiempo> [2] a;

entero x_a = 5 + 1;
buleano encontrado = verdad yy mentira oo mentira;

buleano prueba(entero a, entero& b, lista <lista <DiaSemana>[]>[] &miArray){
    mientras (a == b){
        paraCada(entero i = 0; i < b; i = i + 1){
            b = b + 1;
        }
    }
    devuelve a;
    devuelve b;
}


buleano pruebaConReturn(entero a, entero& b){
    mientras (a == b){
        paraCada(entero i = 0; i < b; i = i + 1){
            b = b + 1;
        }
    }
    
    selecciona (b){
        caso 0: 
            si(a > 1) {
                c = verdad;
            }
        caso 1: 
            c = mentira;
            Â¡para!;
        caso 2:
        porDefecto: a = 3;
    }

    devuelve a;
}

principal(){

    Tiempo t;

    miClase mc = nuevo miClase(t,a);

    matriz m = {{Viernes, Sabado}, {Sabado,Domingo}, {Domingo, Viernes}};

    lista <lista <entero>[2]>[3] miAray = {{1,2}};
    entero i = 0;

    si (mentira == mentira){
        x_a = 1;
        t.segundo = 10;
    }

    sino{
        paraCada (; i < 1 ; i = i + 1){
            buleano a = verdad;
        }
    }
    lista <lista < lista<entero>[3]>[3]>[3] c;
    lista <entero> [3] b;
    entero* n;
    Tiempo* t1;
    t.segundo = 60;
    entero z = t.segundo;
    a[1] = verdad;
    a[i] = c[2][1][2];
    b = c[1][1];
    t.segundo = t1.minuto;
    c[1][2][2] = t.minuto;
    t.minuto = c[1][2][2];

    @m = 1;
    @m = @n;
    entero x = 5 + 2*3 - 1;
    mientras (a > 1){
        x = x + 1;
    }

    entero i = 0;
   entero n = 0;

   lista <lista <entero>[12]> [12] l;

   mientras(i < 12){
    entero j = 0;
    mientras(j < 12){
        j = j + 1;
        l[i][j] = n;
        imprime(l[i][j]);
        n = n + 1;
    }
    i = i + 1;
   }

    
}

(module
(type $_sig_i32i32i32 (func (param i32 i32 i32) ))
(type $_sig_i32ri32 (func (param i32) (result i32)))
(type $_sig_i32 (func (param i32)))
(type $_sig_ri32 (func (result i32)))
(type $_sig_void (func ))
(import "runtime" "exceptionHandler" (func $exception (type $_sig_i32)))
(import "runtime" "print" (func $print (type $_sig_i32)))
(import "runtime" "read" (func $read (type $_sig_ri32)))
(memory 2000)   ;; TODO: Esto se cambia imagino
(global $SP (mut i32) (i32.const 0)) ;; start of stack
(global $MP (mut i32) (i32.const 0)) ;; mark pointer
(global $NP (mut i32) (i32.const 131071996)) ;; heap 2000*64*1024-4
(start $principal)
(func $principal
 (local $localsStart i32)
 (local $temp i32)
 i32.const 584
 call $reserveStack
 set_local $temp
 get_global $MP
 get_local $temp
 i32.store
 get_global $MP
 get_global $SP
 i32.store offset=4
 get_global $MP
 i32.const 8
 i32.add
 set_local $localsStart
;;INICIO DECLARACIONi
i32.const 0
get_local $localsStart
i32.add
i32.const 0
i32.store
;;FIN DECLARACIONi
;;INICIO DECLARACIONn
i32.const 4
get_local $localsStart
i32.add
i32.const 0
i32.store
;;FIN DECLARACIONn

;;INICIO ASIGNACIONAccArr(AccArr(l[0])[0])
get_local $localsStart
;;AQUI ACCESO ARRAY AccArr(l[0])
i32.const 8
i32.add
;;AQUI COMIENZO EXP 0
i32.const 0
;;AQUI FIN EXP 0
i32.const 48
i32.mul
i32.add
;;AQUI FIN ARRAY AccArr(l[0])
;;AQUI ACCESO ARRAY AccArr(AccArr(l[0])[0])

;;AQUI COMIENZO EXP 0
i32.const 0
;;AQUI FIN EXP 0
i32.const 4
i32.mul
i32.load
i32.add
;;AQUI FIN ARRAY AccArr(AccArr(l[0])[0])
i32.const 1
i32.store
;;FIN ASIGNACIONAccArr(AccArr(l[0])[0])
get_local $localsStart
;;AQUI ACCESO ARRAY
;;AQUI ACCESO ARRAY AccArr(l[0])
i32.const 8
i32.add
;;AQUI COMIENZO EXP 0
i32.const 0
;;AQUI FIN EXP 0
i32.const 48
i32.mul
i32.add
;;AQUI FIN ARRAY AccArr(l[0])
;;AQUI ACCESO ARRAY AccArr(AccArr(l[0])[0])

;;AQUI COMIENZO EXP 0
i32.const 0
;;AQUI FIN EXP 0
i32.const 4
i32.mul
i32.load
i32.add
;;AQUI FIN ARRAY AccArr(AccArr(l[0])[0])
i32.load
call $print
 call $freeStack
)
(func $reserveStack (param $size i32)
   (result i32)
   get_global $MP
   get_global $SP
   set_global $MP
   get_global $SP
   get_local $size
   i32.add
   set_global $SP
   get_global $SP
   get_global $NP
   i32.gt_u
   if
   i32.const 3
   call $exception
   end
)
(func $freeStack (type $_sig_void)
   get_global $MP
   i32.load
   i32.load offset=4
   set_global $SP
   get_global $MP
   i32.load
   set_global $MP   
)
(func $reserveHeap (type $_sig_i32)
   (param $size i32)
;; ....
)
(func $copyn (type $_sig_i32i32i32) ;; copy $n i32 slots from $src to $dest
   (param $src i32)
   (param $dest i32)
   (param $n i32)
   block
     loop
       get_local $n
       i32.eqz
       br_if 1
       get_local $n
       i32.const 1
       i32.sub
       set_local $n
       get_local $dest
       get_local $src
       i32.load
       i32.store
       get_local $dest
       i32.const 4
       i32.add
       set_local $dest
       get_local $src
       i32.const 4
       i32.add
       set_local $src
       br 0
     end
   end
)
)

entero i = 0;
   entero n = 0;

   lista <lista <entero>[12]> [12] l;

    l[0][0] = 1;
    imprime(l[0][0]);
